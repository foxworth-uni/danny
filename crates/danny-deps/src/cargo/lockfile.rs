//! Cargo.lock parser using cargo_lock crate

use crate::{Error, LockfileParser, LockedDependencies, LockedPackage, Result};
use cargo_lock::Lockfile;
use danny_fs::FileSystem;
use std::path::Path;
use std::sync::Arc;

/// Cargo.lock parser
pub struct CargoLockfileParser;

impl CargoLockfileParser {
    /// Create a new Cargo lockfile parser
    pub fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl LockfileParser for CargoLockfileParser {
    async fn parse_lockfile<F: FileSystem>(
        &self,
        _fs: &Arc<F>,
        path: &Path,
    ) -> Result<LockedDependencies> {
        // cargo_lock::Lockfile::load requires a Path, so we use the path directly
        // The FileSystem abstraction ensures path validation
        let lockfile = Lockfile::load(path)
            .map_err(|e| Error::CargoLock(e.to_string()))?;

        let packages = lockfile
            .packages
            .iter()
            .map(|pkg| {
                let name = pkg.name.as_str().to_string();
                let locked = LockedPackage {
                    name: name.clone(),
                    version: pkg.version.to_string(),
                    checksum: pkg.checksum.as_ref().map(|c| c.to_string()),
                    resolved: pkg.source.as_ref().map(|s| s.to_string()),
                };
                (name, locked)
            })
            .collect();

        Ok(LockedDependencies { packages })
    }

    async fn verify_integrity<F: FileSystem>(&self, _fs: &Arc<F>, path: &Path) -> Result<()> {
        // cargo_lock crate handles checksum verification automatically
        // Lockfile::load validates checksums during parsing
        let _lockfile = Lockfile::load(path)
            .map_err(|e| Error::CargoLock(e.to_string()))?;
        Ok(())
    }
}

impl Default for CargoLockfileParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_parse_lockfile() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("Cargo.lock");

        // Create a minimal valid Cargo.lock
        std::fs::write(
            &lockfile_path,
            r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "test"
version = "0.1.0"
"#,
        )
        .unwrap();

        let parser = CargoLockfileParser::new();
        let result = parser.parse_lockfile(&lockfile_path);

        // Should parse successfully (even if minimal)
        assert!(result.is_ok());
    }
}

